import { Hono } from "hono";
import { mkdir, writeFile } from "fs/promises";
import { join } from "path";
import type { ApiResponse, FeedbackRequest } from "../types";
import { workerStore } from "../store/workers";

const feedbackRouter = new Hono();

const PROJECT_ROOT = process.env.PROJECT_ROOT || process.cwd();

/**
 * POST /feedback
 * Send feedback from Main Claude to Worker
 */
feedbackRouter.post("/", async (c) => {
  try {
    const request: FeedbackRequest = await c.req.json();

    console.log(`[feedback] Sending feedback to: ${request.worktree}`);
    console.log(`[feedback] Action: ${request.action}`);

    // Validate required fields
    if (!request.worktree || !request.feedback || !request.action) {
      const response: ApiResponse = {
        success: false,
        error: "Missing required fields: worktree, feedback, action",
        timestamp: new Date().toISOString(),
      };
      return c.json(response, 400);
    }

    // Update worker store
    const worker = workerStore.addFeedback(request.worktree, request);

    if (!worker) {
      const response: ApiResponse = {
        success: false,
        error: `Worker not found: ${request.worktree}`,
        timestamp: new Date().toISOString(),
      };
      return c.json(response, 404);
    }

    // Write feedback file to worktree's .claude directory
    const worktreePath = join(PROJECT_ROOT, "..", "worktrees", request.worktree);
    const claudeDir = join(worktreePath, ".claude");
    await mkdir(claudeDir, { recursive: true });

    const feedbackContent = generateFeedbackMarkdown(request);
    const feedbackPath = join(claudeDir, "feedback.md");

    await writeFile(feedbackPath, feedbackContent, "utf-8");

    console.log(`[feedback] Feedback written to: ${feedbackPath}`);

    const response: ApiResponse<{
      worker: typeof worker;
      feedbackPath: string;
    }> = {
      success: true,
      data: {
        worker,
        feedbackPath,
      },
      timestamp: new Date().toISOString(),
    };

    return c.json(response, 200);
  } catch (error) {
    console.error("[feedback] Error sending feedback:", error);

    const response: ApiResponse = {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
      timestamp: new Date().toISOString(),
    };

    return c.json(response, 500);
  }
});

/**
 * GET /feedback/:worktree
 * Get feedback history for a worker
 */
feedbackRouter.get("/:worktree", async (c) => {
  const worktree = c.req.param("worktree");
  const worker = workerStore.get(worktree);

  if (!worker) {
    const response: ApiResponse = {
      success: false,
      error: `Worker not found: ${worktree}`,
      timestamp: new Date().toISOString(),
    };
    return c.json(response, 404);
  }

  const response: ApiResponse<{
    feedbackHistory: FeedbackRequest[];
  }> = {
    success: true,
    data: {
      feedbackHistory: worker.feedbackHistory,
    },
    timestamp: new Date().toISOString(),
  };

  return c.json(response, 200);
});

/**
 * Generate markdown content for feedback file
 */
function generateFeedbackMarkdown(request: FeedbackRequest): string {
  const priorityEmoji = {
    low: "",
    normal: "",
    high: "[URGENT] ",
  };

  const actionInstruction = {
    continue: "Please continue with the implementation based on the feedback below.",
    revise: "Please revise your previous work based on the feedback below.",
    complete: "Your work has been approved. Please finalize any remaining cleanup.",
  };

  const lines = [
    `# Feedback from Main Claude`,
    "",
    `**Time**: ${new Date().toISOString()}`,
    `**Action Required**: ${priorityEmoji[request.priority || "normal"]}${request.action.toUpperCase()}`,
    "",
    `## Instructions`,
    "",
    actionInstruction[request.action],
    "",
    `## Feedback Details`,
    "",
    request.feedback,
    "",
    "---",
    "",
    "*This file was automatically generated by Team Claude. Read this feedback and incorporate it into your next session.*",
    "",
  ];

  return lines.join("\n");
}

export { feedbackRouter };
